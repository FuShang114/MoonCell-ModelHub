# 资源池系统实现总结

> 本文档总结了已实现的资源池系统、分桶算法、对象管理等核心功能，供后续开发参考。

---

## 一、核心架构概述

### 1.1 设计理念

- **资源池存储 ModelInstance 的深拷贝对象**：每个拷贝有独立状态（占用/空闲），避免状态混乱
- **分桶算法只输出范围和权重**：权重表示每个健康 ModelInstance 分配给每个资源池的深拷贝对象数量的比例
- **倒计时释放机制**：对象占用后启动倒计时，到达时间后 CAS 变回空闲，不依赖 SSE 结束
- **动态 T 调整**：每个 ModelInstance 有独立的刷新时延 T，根据对象使用占比和 TPM 使用占比动态调整

### 1.2 请求流程

```
请求 → 入口有界队列 → 消费者取队 → Token 预估 → 路由表 → 资源池 → 
随机采样空闲对象 → CAS 占用 → 组装 message → SSE 发送 → 倒计时释放
```

---

## 二、核心组件

### 2.1 PoolObject（池对象）

**位置**：`com.mooncell.gateway.core.pool.PoolObject`

**核心特性**：
- 存储 ModelInstance 的**深拷贝**（发送信息：URL、headers、body 模板等）
- 存储 message 槽位和 idempotencyKey
- **不存储连接**（连接是有限资源，发送时按需获取）
- 状态：IDLE / BUSY（通过 CAS 原子变更）

**关键方法**：
- `casIdleToBusy()`：CAS 从空闲变占用
- `casBusyToIdle()`：CAS 从占用变空闲
- `acquire(String message, String idempotencyKey, long releaseAtMs)`：占用时设置

**深拷贝实现**：
```java
private static ModelInstance deepCopy(ModelInstance original) {
    // 复制所有字段，创建新对象
    // 运行时状态不复制（每个对象独立）
}
```

---

### 2.2 ResourcePool（资源池接口）

**位置**：`com.mooncell.gateway.core.pool.ResourcePool`

**核心方法**：
- `PoolObject tryAcquire(OpenAiRequest requestPayload, long releaseAtMs)`：随机采样空闲对象，CAS 占用
- `void release(PoolObject poolObject)`：释放对象（CAS 变回空闲）
- `int getObjectCount()`：获取对象总数
- `int getIdleObjectCount()`：获取空闲对象数
- `int getBusyObjectCount()`：获取占用对象数

---

### 2.3 DefaultResourcePool（默认资源池实现）

**位置**：`com.mooncell.gateway.core.pool.DefaultResourcePool`

**核心功能**：
1. **根据分桶策略创建深拷贝对象**：
   - 调用 `ObjectCountCalculator.calculateObjectCounts()` 计算各实例在各池的对象数
   - 为每个健康的 ModelInstance 创建深拷贝对象
   - 根据桶权重分配到对应资源池

2. **随机采样空闲对象**：
   - `randomSampleIdle(int k)`：从空闲集合中随机采样 K 个
   - `tryAcquire()`：随机选一个，CAS 占用，装填 message

3. **对象管理**：
   - `idleObjects`：空闲对象集合（ConcurrentHashMap.newKeySet()）
   - `busyObjects`：占用对象集合（ConcurrentHashMap.newKeySet()）

**关键方法**：
- `refreshObjects()`：根据分桶策略刷新对象池（每 60 秒调用）
- `tryAcquire()`：随机采样 → CAS 占用 → 装填 message
- `release()`：CAS 变回空闲，清空 message

---

### 2.4 ObjectCountCalculator（对象数量计算器）

**位置**：`com.mooncell.gateway.core.pool.ObjectCountCalculator`

**核心功能**：根据 ModelInstance 的 TPM、分桶策略（范围+权重），计算该实例在各资源池的深拷贝对象数。

**计算公式**：

```
① 每个桶分到的 TPM: T_i = T × (weight_i / W)
② 每个桶需要的对象数: n_i = ceil(T_i / max_token_i)
③ 总对象数: N_total = sum(n_i)
```

**Java 实现**：
```java
// 1. 权重归一化
double ratio = (double) bucket.getWeight() / totalWeight;

// 2. 桶 i 分到流量
double tpm_i = totalTpm * ratio;

// 3. 桶 i 对象数（向上取整）
int maxToken = bucket.getTokenRangeMax();
int count_i = (int) Math.ceil(tpm_i / maxToken);

// 至少 1 个（如果该桶有流量分配）
if (tpm_i > 0 && count_i == 0) {
    count_i = 1;
}
```

**关键方法**：
- `calculateObjectCounts(ModelInstance instance, BucketRouteTable routeTable)`：返回各池的对象数分配（poolId -> count）
- `getInstanceTpm(ModelInstance instance)`：获取实例的 TPM（必须配置，不再用 maxQps fallback）

---

### 2.5 RefreshDelayAdjuster（刷新时延调整器）

**位置**：`com.mooncell.gateway.core.pool.RefreshDelayAdjuster`

**核心功能**：每个 ModelInstance 独立的刷新时延 T 的动态调整。

**调整规则**：
1. **降低 T**：对象使用占比 > 0.8 且 TPM 使用占比 < 0.9
2. **升高 T**：TPM 使用占比 >= 1.0

**统计时间段**：分桶策略更新之间的时间段（60 秒周期）

**关键方法**：
- `getT(ModelInstance instance)`：获取实例的当前 T（秒）
- `recordObjectUsage(ModelInstance instance)`：记录对象使用
- `recordTpmUsage(ModelInstance instance, int tokens)`：记录 TPM 使用
- `adjustT(ModelInstance instance)`：根据统计信息调整 T（在分桶策略更新时调用）

**T 范围**：
- 最小值：10 秒
- 最大值：300 秒
- 默认值：60 秒
- 调整步长：5 秒

---

### 2.6 CountdownCalculator（倒计时计算器）

**位置**：`com.mooncell.gateway.core.pool.CountdownCalculator`

**核心功能**：计算对象的倒计时到期时间（releaseAt）。

**公式**：
```
releaseAt = now + (T + phaseOffset) * 1000
```
- T：从 RefreshDelayAdjuster 获取（每个实例独立）
- phaseOffset：随机偏移（±phaseOffsetSeconds），打散到期时间

**关键方法**：
- `calculateReleaseAt(ModelInstance instance)`：计算倒计时到期时间（毫秒）

---

### 2.7 CountdownReleaseScheduler（倒计时释放调度器）

**位置**：`com.mooncell.gateway.core.pool.CountdownReleaseScheduler`

**核心功能**：定期扫描 busy 对象，到达 releaseAt 时 CAS 释放。

**调度频率**：每 1 秒执行一次

**关键方法**：
- `scanAndRelease()`：扫描 busy 对象，释放到期的对象

---

### 2.8 ChatRequestQueue（入口有界队列）

**位置**：`com.mooncell.gateway.core.queue.ChatRequestQueue`

**核心特性**：
- **位置**：在路由之前（请求先入队，再被消费）
- **有界队列**：`LinkedBlockingQueue`，容量可配置
- **入队超时**：`offer(timeout)`，超时返回 false（触发 503）

**关键方法**：
- `boolean offer(RequestContext ctx)`：入队（带超时）
- `RequestContext take()`：出队（阻塞）

---

### 2.9 ChatQueueConsumer（队列消费者）

**位置**：`com.mooncell.gateway.core.queue.ChatQueueConsumer`

**核心流程**：
1. 从队列取请求
2. Token 预估
3. 路由表解析目标资源池
4. 资源池随机采样空闲对象，CAS 占用
5. 记录对象使用统计
6. 计算倒计时到期时间
7. 组装 OpenAiRequest，执行 SSE 发送
8. `doFinally`：记录 TPM 使用统计，释放对象，删除 Redis 键

**关键方法**：
- `process(RequestContext ctx)`：处理单个请求

---

### 2.10 BucketRouteTable（路由表）

**位置**：`com.mooncell.gateway.core.routing.BucketRouteTable`

**核心特性**：
- **双版本路由表**：`currentRoute` / `nextRoute`（ThreadLocal）
- **桶规则**：Token 区间 + 资源池 ID + 权重

**关键方法**：
- `resolvePoolId(int estimatedTokens)`：根据 Token 数解析目标资源池 ID

---

### 2.11 RouteTableHolder（路由表持有者）

**位置**：`com.mooncell.gateway.core.routing.RouteTableHolder`

**核心功能**：
- 维护当前路由表和 poolId → ResourcePool 映射
- 提供 `resolvePool(int estimatedTokens)` 方法

---

### 2.12 BucketStrategyScheduler（分桶策略调度器）

**位置**：`com.mooncell.gateway.core.routing.BucketStrategyScheduler`

**核心功能**：每 60 秒执行一次：
1. 更新分桶策略（TODO：调用分桶算法）
2. 调整各实例的 T（调用 `RefreshDelayAdjuster.adjustT()`）
3. 刷新对象池（调用 `DefaultResourcePool.refreshObjects()`）

**调度频率**：`@Scheduled(fixedRate = 60000)`

---

## 三、关键设计要点

### 3.1 深拷贝 ModelInstance

**原因**：每个池对象有独立状态（占用/空闲、message），若共用同一 ModelInstance 引用，状态会混乱。

**实现**：`PoolObject.deepCopy()` 方法，复制所有字段，创建新对象。

### 3.2 分桶算法输出

**只输出两样东西**：
1. 每个桶的范围（Token 区间）
2. 每个桶的权重

**没有**：目标 TPM、ModelInstance 的权重等。

**权重的含义**：每一个健康的 ModelInstance，分配给每一个资源池的深拷贝对象数量的比例。

### 3.3 对象数量计算公式

**输入**：
- T：ModelInstance 的总 TPM
- max_token_i：第 i 个桶的最大 token 数
- weight_i：第 i 个桶的权重
- W：所有权重和

**计算**：
```
T_i = T × (weight_i / W)
n_i = ceil(T_i / max_token_i)
N_total = sum(n_i)
```

### 3.4 T 动态调整规则

**统计指标**（60 秒周期）：
- 对象使用占比 = 使用过的对象数 / 总对象数
- TPM 使用占比 = 实际使用的 TPM / 总 TPM

**调整规则**：
- 对象使用占比 > 0.8 且 TPM 使用占比 < 0.9：降低 T（减少 5 秒）
- TPM 使用占比 >= 1.0：升高 T（增加 5 秒）

### 3.5 倒计时释放机制

**不依赖 SSE 结束**：对象占用后启动倒计时，到达时间后 CAS 变回空闲。

**倒计时时长 T**：
- 与 RPM/TPM 的 1 分钟窗口平衡
- T 过短：资源超用，触发限流
- T 过长：单对象在 1 分钟内可复用次数少

**相位偏移**：打散各对象的到期时间，避免 CPU 尖峰。

---

## 四、配置文件

### 4.1 application.properties

```properties
# 入口有界队列（路由前）
mooncell.gateway.queue.capacity=1000
mooncell.gateway.queue.offer-timeout-ms=5000
mooncell.gateway.queue.consumer-threads=4

# 对象池配置
mooncell.gateway.pool.max-total-objects=1000
mooncell.gateway.pool.default-pool-max-objects=1000
mooncell.gateway.pool.countdown-seconds=30
mooncell.gateway.pool.sample-count=2
mooncell.gateway.pool.phase-offset-seconds=5
```

### 4.2 数据库字段

**model_instance 表**：
- `tpm INT`：TPM 上限（tokens/minute），用于分桶计算对象数
- **已移除**：`max_qps`（不再使用）

---

## 五、文件清单

### 5.1 核心池对象
- `PoolObject.java`：池对象（深拷贝 ModelInstance + 状态 + message）
- `ResourcePool.java`：资源池接口
- `DefaultResourcePool.java`：默认资源池实现

### 5.2 计算器
- `ObjectCountCalculator.java`：对象数量计算器
- `CountdownCalculator.java`：倒计时计算器
- `RefreshDelayAdjuster.java`：刷新时延调整器

### 5.3 调度器
- `CountdownReleaseScheduler.java`：倒计时释放调度器
- `BucketStrategyScheduler.java`：分桶策略调度器

### 5.4 队列
- `ChatRequestQueue.java`：入口有界队列
- `RequestContext.java`：请求上下文
- `ChatQueueConsumer.java`：队列消费者
- `TokenEstimator.java`：Token 预估器

### 5.5 路由
- `BucketRouteTable.java`：路由表
- `RouteTableHolder.java`：路由表持有者

### 5.6 配置
- `ObjectPoolConfig.java`：对象池配置
- `GatewayQueueProperties.java`：队列配置

---

## 六、待实现功能

### 6.1 分桶算法
- **位置**：`BucketStrategyScheduler.updateBucketStrategy()`
- **TODO**：调用分桶算法，更新 `BucketRouteTable.CURRENT`

### 6.2 策略模式
- **需求**：支持 Traditional 算法（默认）
- **需求**：支持热切换的平滑处理
- **状态**：未实现

### 6.3 双版本路由表切换
- **需求**：原子替换 `currentRoute` → `nextRoute`
- **状态**：路由表结构已支持，切换逻辑待完善

---

## 七、注意事项

1. **TPM 必须配置**：不再使用 maxQps 作为 fallback
2. **深拷贝必须实现**：避免状态混乱
3. **CAS 操作必须原子**：保证并发安全
4. **倒计时释放不依赖 SSE**：由调度器统一释放
5. **统计周期 60 秒**：与分桶策略更新周期一致

---

## 八、关键代码片段

### 8.1 对象数量计算

```java
Map<String, Integer> poolCounts = objectCountCalculator.calculateObjectCounts(instance, routeTable);
Integer count = poolCounts.get(DEFAULT_POOL_ID);
if (count != null && count > 0) {
    for (int i = 0; i < count; i++) {
        PoolObject obj = new PoolObject(objectId, instance);
        idleObjects.add(obj);
    }
}
```

### 8.2 CAS 占用

```java
if (obj.casIdleToBusy()) {
    String message = extractMessage(requestPayload);
    obj.acquire(message, idempotencyKey, releaseAtMs);
    idleObjects.remove(obj);
    busyObjects.add(obj);
    return obj;
}
```

### 8.3 T 动态调整

```java
double objectUsageRatio = (double) usedObjects / totalObjects;
double tpmUsageRatio = (double) usedTpm / totalTpm;

if (objectUsageRatio > 0.8 && tpmUsageRatio < 0.9) {
    newT = Math.max(MIN_T, currentT - T_ADJUSTMENT_STEP);
} else if (tpmUsageRatio >= 1.0) {
    newT = Math.min(MAX_T, currentT + T_ADJUSTMENT_STEP);
}
```

---

**文档版本**：v1.0  
**最后更新**：2026-02-18  
**维护者**：MoonCell Gateway Team
